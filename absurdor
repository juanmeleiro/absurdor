#!/usr/bin/env lua5.4
local argparse = require "argparse"
local json = require "json"
local path = require "path"
local fs = require "path.fs"
local date = require "date"
local pprint = require("pprint").pprint

function die(err, msg)
   msg = tostring(msg or err)
   if err then
      io.stderr:write(msg .. "\n")
      os.exit(1)
   end
end

function maildate(s)
	local d = date(s)
	local sec = date.diff(d, date.epoch()):spanseconds()
	return sec
end

function yn(prompt)
	meaning = {Y = true, y = true, n = false, N = false}
	while meaning[ans] == nil do
		io.write(prompt)
		io.flush()
		ans = io.read(1)
	end
	return meaning[ans]
end

function decodewith(decoder, fn)
   die(not path.exists(fn), fn.." does not exist.")
   die(not path.isfile(fn), fn.." is not a file.")
   local f, err = io.open(fn, "r")
   die(err)
   status, res = xpcall(decoder, die, f:read("a"))
   f:close()
   die(not status, res)
   return res
end

function encodewith(encoder, fn, data)
   local f, err = io.open(fn, "w")
   die(not status, err)
   status, err = f:write(encoder(data))
   die(not status, err)
end

function format(fmt, dict, sett)
   -- A identifier is
   -- > any string of Latin letters, Arabic-Indic digits, and
   -- > underscores, not beginning with a digit and not being a reserved
   -- > word

   -- local reserved = {
   --    "and", "break", "do", "else", "elseif", "end", "false", "for",
   --    "function", "goto", "if", "in", "local", "nil", "not", "or", "repeat",
   --    "return", "then", "true", "until", "while"
   -- }
   res = fmt
   for s in string.gmatch(fmt, "%{([_a-zA-Z][._a-zA-Z0-9]*)%}") do
      local value = dict
      local pref = sett
      for k in string.gmatch(s, "([_a-zA-Z][_a-zA-Z0-9]*)") do
	 if type(value) == "table" then value = value[k] end
	 if type(pref) == "table" then pref = pref[k] end
      end
      if pref and value then string.format(pref, value) end
      res = fmt.gsub(res, "{"..s.."}", value or "nil")
   end
   return res
end

function is_valid_entry(e)
	return (
		(e.what ~= nil) and
		(e.when ~= nil) and
		(e.what ~= "push" or e.who ~= nil) and
		(e.what ~= "report" or e.height ~= nil)
	)
end

function parse_jsonl(f)
	local log = {}
	for l in f:lines() do
		local e = json.decode(l)
		die(not is_valid_entry(e), string.format("Invalid log entry:\n    %s", l))
		table.insert(log, e)
	end
	return log
end

function write_jsonl(l)
	local res = ""
	for _,v in ipairs(l) do
		res = res .. json.encode(v) .. "\n"
	end
	return res
end

function fmt_event(e)
	date = os.date("%Y-%m-%d %H:%M:%S %z", e.when)
	args = {ts = date}
	if e.what == "report" then
		fmt = "[{ts}] Reported boulder at height {height}"
		args.height = e.height 
	elseif e.what == "push" then
		fmt = "[{ts}] {who} pushed the boulder"
		args.who = e.who
	end
	return format(fmt, args)
end

function sec2week(s)
	return math.floor(s/(24 * 60 * 60 * 7))
end

function week2sec(w)
   return w*24*60*60*7
end

function is_duplicate(ts, log)
	for _,e in ipairs(log) do
		if e.when == ts then
			return true
		end
	end
	return false
end

local parser = argparse("absurdor", "Manage Absurdor duties")
	:command_target("command")
local commands = {}

parser:command("report", "Generate and send absurdor report")
	:flag("-p")
commands.record = parser:command("record", "Record events")
	:command_target("what")
commands.push = commands.record:command("push", "A push of The Boulder")
commands.push:argument("who", "Name of the player")
commands.push:argument("when", "Timestamp of boulder push")
	:convert(maildate)
commands.push:option("-m", "Message ID where push happened"):target("where")
commands.log = parser:command("log", "Display log")

commands.transfer = commands.record:command("transfer", "Transfer the Veblen")
commands.transfer:argument("who", "Name of the player")
commands.transfer:argument("when", "When the transfer took place")
	:convert(maildate)
commands.transfer:argument("payed", "Amount spent on the transfer")
	:convert(tonumber)
commands.transfer:option("-m", "Message ID where push happened"):target("where")

local args = parser:parse()

fn = "log.json"
log = decodewith(json.decode, fn)

if args.command == "report" then

	height = 0
	local plot = {}
	local pushed = {}
	local max = 1
	local failed = false
	local who = {}
	local players = {}
	local veblen = {
		cost = 1,
		history = {},
		namewidth = 0
	}

	if #log > 0 then
		start = sec2week(log[1].when)
	end

	for i,e in ipairs(log) do
		if e.what == "push" then
			local w = sec2week(e.when) - start
			if pushed[w-1] or pushed[w] or week2sec(sec2week(e.when)) < 1693159683 then
				-- At 1693159683 seconds from Unix epoch, the governing
				-- rule was changed so that the Boulder falls to zero
				-- if it was not pushed the previous week. However, the
				-- change is not retroactive; hence the magic number.
				height = (height + 1)
			else
				height = 1
			end
			plot[w] = height
			who[w] = who[w] or {}
			table.insert(who[w], e.who)
			pushed[w] = true
			if height >= plot[max] then
				max = w
			end
			if players[e.who] then
				players[e.who] = players[e.who] + 1
			else
				players[e.who] = 1
			end
		elseif e.what == "transfer" then
			die(e.payed < veblen.cost, string.format("Recorded transfer by %s used less spendies (%d) than the current Veblen cost (%s)", e.who, e.payed, veblen.cost))
			if veblen.current then table.insert(veblen.history, veblen.current) end
			veblen.current = {who = e.who, payed = e.payed, cost = veblen.cost, when = e.when}
			veblen.cost = e.payed + 1
			veblen.namewidth = math.max(veblen.namewidth, string.len(e.who))
		end
	end

	table.insert(veblen.history, veblen.current)

	local w = sec2week(os.time()) - start
	if (not (w == 0)) and (not pushed[w-1]) then
		failed = true
		if not pushed[w] then
			height = 0
			plot[w] = 0
		end
	end

	local cur = 0
	for i = 1, max do
		if plot[i] then
			cur = plot[i]
		else
			plot[i] = cur
		end
	end

	vars = {
		YYYY = os.date("%Y"),
		MM = os.date("%m"),
		DD = os.date("%d"),
		N = height
	}

	defs = ""

	for k, v in pairs(vars) do
		defs = defs .. string.format(" --define=%s=%s", k, v)
	end

	tmpname = ".tmp"
	-- Height banner
	os.execute(string.format("m4 %s template.m4 >> %s", defs, tmpname))

	f = io.open(tmpname, "a")

	-- Top pushers
	f:write("TOP PUSHERS\n")
	local scores = {}
	for p,v in pairs(players) do
		table.insert(scores, {player = p, pushes = v})
	end
	table.sort(scores, function (s0, s1) return s0.pushes > s1.pushes end)
	for i,s in ipairs(scores) do
		f:write(string.format("#%02d %2d %s %s\n", i, s.pushes, string.rep("=", s.pushes), s.player))
	end
	f:write("\n")

	-- Height graph
	f:write("THE ROAD SO FAR\n")
	for i = #plot, 1, -1 do
		f:write("|", string.rep("#", math.floor(30*plot[i]/max) or 0))
		if i == max then
			f:write(" <- the heighest we've ever reached!")
		elseif i == #plot then
			f:write(" <- where we are now.")
		end
		f:write(" ")
		f:write(table.concat(who[i] or {}, ", "))
		f:write("\n")
	end

	f:write("\n----------------------------------------------------------------------\nTHE VEBLEN\n\n")
	f:write("          The Veblen\n")
	f:write(string.format("          is owned by %s\n\n", veblen.current.who))

	f:write("HISTORY\n")
	table.sort(veblen.history, function(x,y) return x.cost > y.cost end)
	for _,e in ipairs(veblen.history) do
		f:write(string.format("[%s] %s %s%s\n", os.date("%Y-%m-%d %H:%M %z", args.when), string.rep(" ", veblen.namewidth - string.len(e.who)) .. e.who, string.rep("-", e.cost), string.rep("+", e.payed - e.cost)))
	end
	f:write('[2024-07-18 02:59 +0000] The Veblen is created')
	f:write("\n\n")

	f:write("----------------------------------------------------------------------\n")
	f:write("Do you have any suggestions on what I should put on the report?\n")
	f:write("Send them to me!\n")
	f:write("======================================================================\n")
	f:close()

	if args.p then
		os.execute(string.format("cat %s", tmpname))
		os.remove(tmpname)
	else
		os.execute(string.format("neomutt -H %s -E", tmpname))

		if yn("Archive report? [Yn] ") then
			table.insert(log, {
							 when = os.time(),
							 what = "report",
							 height = height,
							 cost = veblen.cost,
							 owner = veblen.current.who
			})
			os.rename(tmpname, string.format("archive/%s", os.date("%F")))
		else
			os.remove(tmpname)
		end
	end
elseif args.command == "record" then
	if args.what == "push" then
		io.write(string.format("%s pushed the boulder at %s\n", args.who, os.date("%Y-%m-%d %H:%M %z", args.when)))
		table.insert(log, {
						 when = args.when,
						 what = "push",
						 who = args.who,
						 where = args.where
		})
	elseif args.what == "transfer" then
		io.write(string.format("%s transfered the Veblen to emself for %d spendies.\n", args.who, args.payed))
		table.insert(log, {
			when = args.when,
			what = "transfer",
			who = args.who,
			where = args.where,
			payed = args.payed
		})
	end
elseif args.command == "log" then
	for _,e in ipairs(log) do
		io.write(fmt_event(e).."\n")
	end
end

encodewith(json.encode, fn, log)
os.execute(string.format('jq --sort-keys . %s > .tmp', fn))
os.execute(string.format('mv .tmp %s', fn))
